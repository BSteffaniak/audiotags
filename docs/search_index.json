[["index.html", "audiotags Manual Preface", " audiotags Manual Tianyi Shi 2020-10-27 Preface Thank you for considering audiotags! Before you start, please let me introduce to you some great features of bookdown: use left and right arrow keys to navigate to the previous/next page click the “font” (big “A”) button on the top-left and change to a serif font if you happen to hate sans-serif fonts as I do. If you believe that serious stuff must be rendered by LaTeX as I do, there is a LaTex-rendered PDF for you to download (click the download button on the top) If you love to read on a Kindle, there is also an epub output (click the download button on the top). Examples in this manual If you want to run the examples in this book: clone the repo and navigate into it create src/main.rs all examples, unless otherwise specified, can be copied verbatim from this book to src/main.rs and run with cargo run (if you’re reading it online, the copy button wil show if you hover over a code block) "],["start-simple.html", "Chapter 1 Start Simple", " Chapter 1 Start Simple The following example shows how you can read an audio file, parse, set, and save its metadata: use audiotags::{MimeType, Picture, Tag, TagType}; const MP3_FILE: &amp;&#39;static str = &quot;assets/a.mp3&quot;; fn main() { // using `default()` so that the metadata format is guessed // (from the file extension) (in this case, Id3v2 tag is read) let mut tag = Tag::default().read_from_path(MP3_FILE).unwrap(); // You can also specify the metadata format (tag type): let _tag = Tag::with_tag_type(TagType::Id3v2) .read_from_path(MP3_FILE) .expect(&quot;Fail to read!&quot;); tag.set_title(&quot;foo title&quot;); assert_eq!(tag.title(), Some(&quot;foo title&quot;)); tag.remove_title(); assert!(tag.title().is_none()); tag.remove_title(); // trying to remove a field that&#39;s already empty won&#39;t hurt let cover = Picture { mime_type: MimeType::Jpeg, data: &amp;vec![0u8; 10], }; tag.set_album_cover(cover.clone()); assert_eq!(tag.album_cover(), Some(cover)); tag.remove_album_cover(); assert!(tag.album_cover().is_none()); tag.remove_album_cover(); tag.save_to_path(MP3_FILE).expect(&quot;Fail to save&quot;); // TASK: reload the file and prove the data have been saved } "],["conversion.html", "Chapter 2 Conversion", " Chapter 2 Conversion The following example shows how you can read the tag in an mp3 file, convert it into an mp4 tag, and write it to an m4a file. use audiotags::{Config, Tag, TagType}; fn main() { // we have an mp3 and an m4a file const MP3_FILE: &amp;&#39;static str = &quot;assets/a.mp3&quot;; const M4A_FILE: &amp;&#39;static str = &quot;assets/a.m4a&quot;; // read tag from the mp3 file. Using `default()` so that the type of tag is guessed from the file extension let mut mp3tag = Tag::default().read_from_path(MP3_FILE).unwrap(); // set the title mp3tag.set_title(&quot;title from mp3 file&quot;); // we can convert it to an mp4 tag and save it to an m4a file. let mut mp4tag = mp3tag.into_tag(TagType::Mp4); mp4tag.write_to_path(M4A_FILE).unwrap(); // reload the tag from the m4a file; this time specifying the tag type (you can also use `default()`) let mut mp4tag = Tag::with_tag_type(TagType::Mp4) .read_from_path(M4A_FILE) .unwrap(); // the tag originated from an mp3 file is successfully written to an m4a file! assert_eq!(mp4tag.title(), Some(&quot;title from mp3 file&quot;)); // multiple artists mp4tag.add_artist(&quot;artist1 of mp4&quot;); mp4tag.add_artist(&quot;artist2 of mp4&quot;); assert_eq!( mp4tag.artists(), Some(vec![&quot;artist1 of mp4&quot;, &quot;artist2 of mp4&quot;]) ); // convert to id3 tag, which does not support multiple artists mp4tag.set_config(Config::default().sep_artist(&quot;/&quot;)); // separator is by default `;` but we can customise it let mp3tag = mp4tag.into_tag(TagType::Id3v2); assert_eq!(mp3tag.artist(), Some(&quot;artist1 of mp4/artist2 of mp4&quot;)); } "],["anytag.html", "Chapter 3 AnyTag", " Chapter 3 AnyTag The following example shows how you can create a “generic” AnyTag and convert it into a specific tag type. use audiotags::{AnyTag, AudioTagEdit, Id3v2Tag}; fn main() { let mut tag = AnyTag::default(); tag.set_title(&quot;foo&quot;); tag.set_year(2001); let tag: Id3v2Tag = tag.into(); assert_eq!(tag.year(), Some(2001)); tag.write_to_path(&quot;assets/a.mp3&quot;).unwrap(); } "],["downcast.html", "Chapter 4 Downcast", " Chapter 4 Downcast The following example shows how you can downcast a Box&lt;dyn AudioTag&gt; into its “backend” tag type. This allows you to set the uncommon metadata supported by the corresponding backend but not by audiotags. use audiotags::*; fn main() { let mut innertag = metaflac::Tag::default(); innertag .vorbis_comments_mut() .set_title(vec![&quot;title from metaflac::Tag&quot;]); let tag: FlacTag = innertag.into(); let mut id3tag = tag.into_tag(TagType::Id3v2); id3tag .write_to_path(&quot;assets/a.mp3&quot;) .expect(&quot;Fail to write!&quot;); let id3tag_reload = Tag::default() .read_from_path(&quot;assets/a.mp3&quot;) .expect(&quot;Fail to read!&quot;); assert_eq!(id3tag_reload.title(), Some(&quot;title from metaflac::Tag&quot;)); let mut id3tag_inner: id3::Tag = downcast!(id3tag_reload, Id3v2Tag); let timestamp = id3::Timestamp { year: 2013, month: Some(2u8), day: Some(5u8), hour: Some(6u8), minute: None, second: None, }; id3tag_inner.set_date_recorded(timestamp.clone()); id3tag_inner .write_to_path(&quot;assets/a.mp3&quot;, id3::Version::Id3v24) .expect(&quot;Fail to write!&quot;); let id3tag_reload = id3::Tag::read_from_path(&quot;assets/a.mp3&quot;).expect(&quot;Fail to read!&quot;); assert_eq!(id3tag_reload.date_recorded(), Some(timestamp)); } "],["references.html", "References", " References "]]
